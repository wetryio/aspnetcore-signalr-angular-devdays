{"codeFragments":[{"label":"abstract start","content":"return new Observable((observer) => {\n      if (!this.connected.getValue()) {\n        this.init();\n        from(this.connection.start()).subscribe(\n          () => {\n            this.connected.next(true);\n            observer.next(true);\n          },\n          () => {\n            this.connected.next(false);\n            observer.error(false);\n          },\n          () => observer.complete()\n        );\n      } else {\n        console.warn('already connected');\n        observer.next(false);\n        observer.complete();\n      }\n    }).pipe(\n      retryWhen(errors => {\n        return errors.pipe(delayWhen(val => timer(this.connectionTryDelay)));\n      })\n    );"},{"label":"abstract stop","content":"if (this.connection) {\n      this.connection.stop();\n      this.connection = null;\n    } else {\n      console.warn('not connected yet');\n    }"},{"label":"abstract init","content":"if (!this.connection) {\n      this.connection = new HubConnectionBuilder()\n        .withUrl(`${this.baseUrl}${this.url}`, {\n          accessTokenFactory: () => this.loginToken,\n          ... ( this.transport ? { transport: this.transport } : {})\n        })\n        .build();\n      this.registerMethods();\n    }"},{"label":"abstract registerMethods","content":"this.connection.onclose((error) => this.onClose(error));\n    for (const key in this.methods) {\n      if (key) {\n        this.connection.on(key, this.methods[key]);\n      }\n    }"},{"label":"abstract onClose","content":"this.connected.next(false);\n    // Will receive error if connection error but undefined if stop function is called\n    if (error) {\n      if (error instanceof HttpError || error.message.includes(' 1006 ')) {\n        this.start().subscribe();\n      } else {\n        this.logout();\n      }\n    }"},{"label":"abstract send","content":"return from(this.connection.send(methodName, ...datas));"},{"label":"core loginToken","content":"if (typeof localStorage !== undefined) {\n            return localStorage.getItem(loginTokenKey);\n        }"},{"label":"core logout","content":"localStorage.removeItem(loginTokenKey);"},{"label":"quoteService obs","content":"private _quoteReceiver = new Subject<string>();\n  public quoteReceiver = this._quoteReceiver.asObservable();"},{"label":"quoteService config","content":"protected transport = HttpTransportType.LongPolling;\n  protected connectionTryDelay = 10000;"},{"label":"quoteService IMethods","content":"UpdateQuote: SignalrMethod;"},{"label":"quoteService methods","content":"UpdateQuote: (quote) => this._quoteReceiver.next(quote)"},{"label":"quoteService run","content":"return this.start().pipe(\n      switchMap(() => this.quoteReceiver)\n    );"},{"label":"quoteService close","content":"this.stop();"},{"label":"authComp inject","content":",\n    private quoteService: QuoteService"},{"label":"authComp subscribe","content":"this.quoteSubscription = this.quoteService.run().subscribe(quote => this.quote = quote);"},{"label":"authComp destroy","content":"if (this.quoteSubscription) {\n      this.quoteSubscription.unsubscribe();\n    }\n    this.quoteService.close();"},{"label":"chatService obs","content":"private _messageReceiver = new Subject<Message>();\n  public messageReceiver = this._messageReceiver.asObservable();\n\n  private _refreshUserList = new EventEmitter<boolean>();\n  public refreshUserList = this._refreshUserList.asObservable();"},{"label":"chatService IMethods","content":"receive: SignalrMethod;\n  updateUserList: SignalrMethod;"},{"label":"chatService methods","content":"receive: (...data) => this.receive(...data),\n    updateUserList: () => this._refreshUserList.emit(true)"},{"label":"chatService logout","content":"super.logout();\n    this.router.navigate(['/auth']);"},{"label":"chatService listen","content":"return this.start().pipe(\n      switchMap(() => this.messageReceiver)\n    );"},{"label":"chatService receive","content":"this._messageReceiver.next({\n      userId: data[0],\n      content: data[1]\n    });"},{"label":"chatService sendMessage","content":"this.send('SendMessageToUserAsync', receiverId, message);"},{"label":"store obs","content":"private messageSubscription: Subscription;\n    private usersSubscription: Subscription;"},{"label":"store constructor","content":", private chatService: ChatService"},{"label":"store connected","content":"return this.chatService.connected;"},{"label":"store start","content":"this.messageSubscription = this.chatService.listen().subscribe((message) => {\n            this.addMessage(message);\n        });\n        this.usersSubscription = this.chatService.refreshUserList.subscribe(() => {\n            this.refreshUserList();\n        });"},{"label":"store stop","content":"if (this.messageSubscription) {\n            this.messageSubscription.unsubscribe();\n        }\n        if (this.usersSubscription) {\n            this.usersSubscription.unsubscribe();\n        }\n        this.chatService.stopListening();"},{"label":"store addMessage","content":"if (message.mine) {\n            this.chatService.sendMessage(message.userId, message.content);\n        }"}]}